# generated by fastapi-codegen:
#   filename:  openapi.yaml
#   timestamp: 2025-06-28T18:14:10+00:00

from __future__ import annotations

from datetime import date as date_aliased
from enum import Enum
from typing import Any, Dict, List, Optional
from uuid import UUID

from pydantic import BaseModel, ConfigDict, Field, RootModel, constr


class Data(BaseModel):
    modifiedDate: Optional[str] = Field(
        None,
        description='The date on which this account categories were last modified in Codat.',
        examples=['2022-10-23'],
        title='Date',
    )


class AccountCategory(BaseModel):
    detailType: Optional[str] = Field(
        None, description='Most granular chart of account type.'
    )
    subtype: Optional[str] = Field(None, description='The account subtype.')
    type: Optional[str] = Field(None, description='The top level account type.')


class Category(AccountCategory):
    detailTypeDescription: Optional[str] = Field(
        None,
        description='A description of the fully categorized (to detail type) account.',
    )
    detailTypeDisplayName: Optional[str] = Field(
        None, description='Human readable detailType display name.'
    )
    subtypeDisplayName: Optional[str] = Field(
        None, description='Human readable subtype display name.'
    )


class Categories(RootModel[List[Category]]):
    root: List[Category]


class AccountRef1(BaseModel):
    id: str = Field(
        ...,
        description='A unique, persistent identifier for this record',
        examples=[
            '13d946f0-c5d5-42bc-b092-97ece17923ab',
            '9wg4lep4ush5cxs79pl8sozmsndbaukll3ind4g7buqbm1h2',
            7110701885,
            'EILBDVJVNUAGVKRQ',
        ],
    )


class Category1(BaseModel):
    accountRef: Optional[AccountRef1] = None
    confirmed: Optional[AccountCategory] = None


class ConfirmCategories(BaseModel):
    categories: Optional[List[Category1]] = Field(
        None,
        description='List of confirmed account categories set manually by the user. ',
    )


class ConfirmCategory(BaseModel):
    confirmed: AccountCategory


class Currency(RootModel[str]):
    root: str = Field(
        ...,
        description='The currency data type in Codat is the [ISO 4217](https://en.wikipedia.org/wiki/ISO_4217) currency code, e.g. _GBP_.\n\n## Unknown currencies\n\nIn line with the ISO 4217 specification, the code _XXX_ is used when the data source does not return a currency for a transaction. \n\nThere are only a very small number of edge cases where this currency code is returned by the Codat system.',
        examples=['GBP', 'USD', 'EUR'],
        title='Currency',
    )


class CurrencyRate(RootModel[Optional[float]]):
    root: Optional[float] = Field(
        None,
        description='Rate to convert the total amount of the payment into the base currency for the company at the time of the payment.\n\nCurrency rates in Codat are implemented as the multiple of foreign currency units to each base currency unit.  \n\nWhere the currency rate is provided by the underlying accounting platform, it will be available from Codat with the same precision (up to a maximum of 9 decimal places). \n\nFor accounting platforms which do not provide an explicit currency rate, it is calculated as `baseCurrency / foreignCurrency` and will be returned to 9 decimal places.\n\n## Examples with base currency of GBP\n\n| Foreign Currency | Foreign Amount | Currency Rate | Base Currency Amount (GBP) |\n| :--------------- | :------------- | :------------ | :------------------------- |\n| **USD**          | $20            | 0.781         | £15.62                     |\n| **EUR**          | €20            | 0.885         | £17.70                     |\n| **RUB**          | ₽20            | 0.011         | £0.22                      |\n\n## Examples with base currency of USD\n\n| Foreign Currency | Foreign Amount | Currency Rate | Base Currency Amount (USD) |\n| :--------------- | :------------- | :------------ | :------------------------- |\n| **GBP**          | £20            | 1.277         | $25.54                     |\n| **EUR**          | €20            | 1.134         | $22.68                     |\n| **RUB**          | ₽20            | 0.015         | $0.30                      |',
        title='Currency rate',
    )


class ExcelStatus(BaseModel):
    errorMessage: Optional[str] = None
    fileSize: Optional[int] = None
    inProgress: Optional[bool] = None
    lastGenerated: Optional[str] = Field(
        None,
        description='In Codat\'s data model, dates and times are represented using the <a class="external" href="https://en.wikipedia.org/wiki/ISO_8601" target="_blank">ISO 8601 standard</a>. Date and time fields are formatted as strings; for example:\n\n```\n2020-10-08T22:40:50Z\n2021-01-01T00:00:00\n```\n\n\n\nWhen syncing data that contains `DateTime` fields from Codat, make sure you support the following cases when reading time information:\n\n- Coordinated Universal Time (UTC): `2021-11-15T06:00:00Z`\n- Unqualified local time: `2021-11-15T01:00:00`\n- UTC time offsets: `2021-11-15T01:00:00-05:00`\n\n> Time zones\n> \n> Not all dates from Codat will contain information about time zones.  \n> Where it is not available from the underlying platform, Codat will return these as times local to the business whose data has been synced.',
        examples=['2022-10-23T00:00:00Z'],
        title='Date time',
    )
    lastInvocationId: Optional[str] = None
    queued: Optional[str] = None
    reportType: Optional[str] = None
    success: Optional[bool] = None


class PeriodUnit(Enum):
    Month = 'Month'
    Week = 'Week'
    Day = 'Day'


class HalRef(BaseModel):
    href: Optional[str] = None


class Links(BaseModel):
    current: HalRef
    next: Optional[HalRef] = None
    previous: Optional[HalRef] = None
    self: HalRef


class PagingInfo(BaseModel):
    field_links: Links = Field(..., alias='_links')
    pageNumber: int
    pageSize: int
    totalResults: int


class DataType(Enum):
    banking_accounts = 'banking-accounts'
    banking_transactions = 'banking-transactions'
    bankAccounts = 'bankAccounts'
    accountTransactions = 'accountTransactions'


class ReportType(Enum):
    audit = 'audit'
    enhancedFinancials = 'enhancedFinancials'


class DataCompaniesCompanyIdAssessExcelDownloadGetResponse(BaseModel):
    pass


class DataCompaniesCompanyIdAssessExcelDownloadPostResponse(BaseModel):
    pass


class PeriodUnit1(Enum):
    Day = 'Day'
    Week = 'Week'
    Month = 'Month'
    Year = 'Year'


class Schema(RootModel[UUID]):
    root: UUID = Field(
        ...,
        description='Unique identifier for your SMB in Codat.',
        examples=['8a210b68-6988-11ed-a1eb-0242ac120002'],
    )


class SchemaModel(RootModel[UUID]):
    root: UUID = Field(
        ...,
        description="Unique identifier for a company's data connection.",
        examples=['2e9d2c44-f675-40ba-8049-353bfcb5e171'],
    )


class AccountRef(BaseModel):
    id: Optional[str] = Field(None, description="'id' from the Accounts data type.")
    name: Optional[str] = Field(None, description="'name' from the Accounts data type.")


class DataIntegrityMatch(BaseModel):
    amount: Optional[str] = Field(None, description='The transaction value.')
    connectionId: Optional[UUID] = Field(
        None,
        description='ID GUID representing the connection of the accounting or banking platform.',
    )
    currency: Optional[Currency] = Field(
        None, description='The currency of the transaction.'
    )
    date: Optional[str] = Field(None, description='The date of the transaction.')
    description: Optional[str] = Field(None, description='The transaction description.')
    id: Optional[str] = Field(None, description='ID GUID of the transaction.')
    type: Optional[str] = Field(
        None,
        description="The data type which the data type in the URL has been matched against. For example, if you've matched accountTransactions and banking-transactions, and you call this endpoint with accountTransactions in the URL, this property would be banking-transactions.",
    )


class DataIntegrityAmounts(BaseModel):
    currency: Optional[Currency] = None
    max: Optional[float] = Field(None, description='Highest value of transaction set.')
    min: Optional[float] = Field(None, description='Lowest value of transaction set.')


class DataIntegrityConnectionId(BaseModel):
    source: Optional[List[str]] = Field(
        None,
        description='An array of strings. The connection IDs for the type specified in the url.',
    )
    target: Optional[List[str]] = Field(
        None,
        description='An array of strings. The connection IDs for the type being matched to.',
    )


class DataIntegrityByAmount(BaseModel):
    currency: Optional[Currency] = None
    matchPercentage: Optional[float] = Field(
        None,
        description='The percentage of the absolute value of transactions of the type specified in the route which have a match.',
    )
    matched: Optional[float] = Field(
        None,
        description='The sum of the absolute value of transactions of the type specified in the route which have a match.',
    )
    total: Optional[float] = Field(
        None, description='The total of unmatched and matched.'
    )
    unmatched: Optional[float] = Field(
        None,
        description="The sum of the absolute value of transactions of the type specified in the route which don't have a match.",
    )


class DataIntegrityByCount(BaseModel):
    matchPercentage: Optional[float] = Field(
        None,
        description='The percentage of records of the type specified in the route which have a match.',
    )
    matched: Optional[float] = Field(
        None,
        description='The number of records of the type specified in the route which do have a match.',
    )
    total: Optional[float] = Field(
        None, description='The total of unmatched and matched.'
    )
    unmatched: Optional[float] = Field(
        None,
        description="The number of records of the type specified in the route which don't have a match.",
    )


class DataIntegrityType(BaseModel):
    type: Optional[str] = Field(
        None,
        description="The data type which the data type in the URL has been matched against. For example, if you've matched accountTransactions and banking-transactions, and you call this endpoint with accountTransactions in the URL, this property would be banking-transactions.",
    )


class ReportInfo(BaseModel):
    companyName: Optional[str] = Field(
        None, description='The name of the company being queried.'
    )
    generatedDate: Optional[str] = Field(
        None, description='Date the report was generated'
    )
    pageNumber: Optional[int] = Field(
        None, description='The number of the page queried.'
    )
    pageSize: Optional[int] = Field(
        None, description='The number of transactions returned per page.'
    )
    reportName: Optional[str] = Field(None, description='Name of the report')
    totalResults: Optional[int] = Field(
        None,
        description='The total number of transactions available for a company for the period specified in the query string.',
    )


class LastGenerated(RootModel[str]):
    root: str = Field(
        ...,
        description='In Codat\'s data model, dates and times are represented using the <a class="external" href="https://en.wikipedia.org/wiki/ISO_8601" target="_blank">ISO 8601 standard</a>. Date and time fields are formatted as strings; for example:\n\n```\n2020-10-08T22:40:50Z\n2021-01-01T00:00:00\n```\n\n\n\nWhen syncing data that contains `DateTime` fields from Codat, make sure you support the following cases when reading time information:\n\n- Coordinated Universal Time (UTC): `2021-11-15T06:00:00Z`\n- Unqualified local time: `2021-11-15T01:00:00`\n- UTC time offsets: `2021-11-15T01:00:00-05:00`\n\n> Time zones\n> \n> Not all dates from Codat will contain information about time zones.  \n> Where it is not available from the underlying platform, Codat will return these as times local to the business whose data has been synced.',
        examples=['2022-10-23T00:00:00Z'],
        title='Date time',
    )


class Type(Enum):
    UncategorizedAccounts = 'UncategorizedAccounts'
    MissingInputData = 'MissingInputData'
    InputDataError = 'InputDataError'


class Key(Enum):
    Unknown = 'Unknown'
    EBITDA = 'EBITDA'
    DebtServiceCoverageRatio = 'DebtServiceCoverageRatio'
    CurrentRatio_QuickRatio = 'CurrentRatio QuickRatio'
    GrossProfitMargin = 'GrossProfitMargin'
    FixedChargeCoverageRatio = 'FixedChargeCoverageRatio'
    WorkingCapital = 'WorkingCapital'
    FreeCashFlow = 'FreeCashFlow'
    NetProfitMargin = 'NetProfitMargin'
    ReturnOnAssetsRatio = 'ReturnOnAssetsRatio'
    ReturnOnEquityRatio = 'ReturnOnEquityRatio'
    OperatingProfitMargin = 'OperatingProfitMargin'
    DeptToEquity = 'DeptToEquity'
    DebtToAssets = 'DebtToAssets'
    InterestCoverageRatio = 'InterestCoverageRatio'
    CashRatio = 'CashRatio'
    InventoryTurnoverRatio = 'InventoryTurnoverRatio'
    AssetTurnoverRatio = 'AssetTurnoverRatio'
    WorkingCapitalTurnoverRatio = 'WorkingCapitalTurnoverRatio'
    DaysSalesOutstanding = 'DaysSalesOutstanding'
    DaysPayablesOutstanding = 'DaysPayablesOutstanding'


class MetricUnit(Enum):
    Ratio = 'Ratio'
    Money = 'Money'


class Type1(Enum):
    MissingAccountData = 'MissingAccountData'
    DatesOutOfRange = 'DatesOutOfRange'


class Input(BaseModel):
    name: Optional[str] = Field(
        None,
        description='The name of the metric input e.g. “Current Assets”, “Capital Expenditure”.',
    )
    value: Optional[float] = Field(
        None, description='The positive or negative number of the input value.'
    )


class Type2(Enum):
    DataNotSynced = 'DataNotSynced'
    DataNotSupported = 'DataNotSupported'
    DataSyncFailed = 'DataSyncFailed'
    DataTypeNotEnabled = 'DataTypeNotEnabled'


class FinancialMetricError(BaseModel):
    message: Optional[str] = Field(
        None, examples=['Account categories data has not been synced']
    )
    type: Optional[Type2] = None


class Item(BaseModel):
    index: Optional[int] = None


class ReportDimension(BaseModel):
    displayName: Optional[str] = None
    index: Optional[int] = None
    items: Optional[List[Item]] = None
    type: Optional[str] = None


class ReportError(BaseModel):
    details: Optional[Dict[str, List[str]]] = None
    message: Optional[str] = None
    type: Optional[str] = None


class ReportMeasure(BaseModel):
    displayName: Optional[str] = None
    index: Optional[int] = None
    type: Optional[str] = None
    units: Optional[str] = None


class IntegrityStatus(Enum):
    Unknown = 'Unknown'
    DoesNotExist = 'DoesNotExist'
    Error = 'Error'
    Complete = 'Complete'


class CustomerRef(BaseModel):
    companyName: Optional[str] = Field(
        None, description='`customerName` from the Customer data type'
    )
    id: constr(min_length=1) = Field(
        ..., description='`id` from the Customers data type'
    )


class InvoiceStatus(Enum):
    Unknown = 'Unknown'
    Draft = 'Draft'
    Submitted = 'Submitted'
    PartiallyPaid = 'PartiallyPaid'
    Paid = 'Paid'
    Void = 'Void'


class Metadata(BaseModel):
    isDeleted: Optional[bool] = Field(
        None,
        description='Indicates whether the record has been deleted in the third-party system this record originated from.',
    )


class PaymentMethodRef(BaseModel):
    id: Optional[str] = Field(
        None, description='`id` from the Payment Methods data type'
    )
    name: Optional[str] = Field(
        None, description='`name` from the Payment Methods data type'
    )


class SupplementalData(BaseModel):
    content: Optional[Dict[str, Dict[str, Any]]] = None


class AccountCategoryLevel(BaseModel):
    confidence: Optional[float] = Field(
        None,
        description='Confidence level of the category. This will only be populated where `status` is `Suggested`.',
    )
    levelName: Optional[str] = Field(None, description='Account category name.')


class AssessErrorDetails(RootModel[Optional[Dict[str, List[str]]]]):
    root: Optional[Dict[str, List[str]]] = None


class ReportComponentMeasure(BaseModel):
    index: Optional[int] = None
    measureDisplayName: Optional[str] = None
    value: Optional[float] = None


class Field1(BaseModel):
    modifiedDate: Optional[LastGenerated] = Field(
        None, description='The date on which this record was last modified in Codat.'
    )


class SourceRef(BaseModel):
    sourceType: Optional[str] = None


class TransactionCategory(BaseModel):
    confidence: Optional[float] = Field(
        None,
        description='Returns the confidence of the suggested category for the transaction.',
    )
    levels: Optional[List[str]] = Field(
        None,
        description='An array of category levels against an individual transaction.',
    )


class PaymentLinkType(Enum):
    Unknown = 'Unknown'
    Unlinked = 'Unlinked'
    Invoice = 'Invoice'
    CreditNote = 'CreditNote'
    Other = 'Other'
    Refund = 'Refund'
    Payment = 'Payment'
    PaymentOnAccount = 'PaymentOnAccount'
    ManualJournal = 'ManualJournal'
    Discount = 'Discount'


class AccountCategoriesUpdatedWebhook(BaseModel):
    alertId: Optional[UUID] = Field(None, description='Unique identifier of the alert.')
    clientId: Optional[UUID] = Field(
        None, description='Unique identifier for your client in Codat.'
    )
    clientName: Optional[str] = Field(None, description='Name of your client in Codat.')
    companyId: Optional[Schema] = None
    data: Optional[Data] = None
    dataConnectionId: Optional[SchemaModel] = None
    message: Optional[str] = Field(
        None, description='A human readable message about the webhook.'
    )
    ruleId: Optional[UUID] = Field(None, description='Unique identifier for the rule.')
    ruleType: Optional[str] = Field(None, description='The type of rule.')


class DataIntegrityDetails(BaseModel):
    amount: Optional[float] = Field(None, description='The transaction value.')
    connectionId: Optional[UUID] = Field(
        None,
        description='ID GUID representing the connection of the accounting or banking platform.',
    )
    currency: Optional[Currency] = Field(
        None, description='The currency of the transaction.'
    )
    date: Optional[LastGenerated] = Field(
        None, description='The date of the transaction.'
    )
    description: Optional[str] = Field(None, description='The transaction description.')
    id: Optional[str] = Field(None, description='ID GUID of the transaction.')
    matches: Optional[List[DataIntegrityMatch]] = None
    type: Optional[str] = Field(None, description='The data type of the record.')


class DataIntegritySummary(DataIntegrityType):
    byAmount: Optional[DataIntegrityByAmount] = None
    byCount: Optional[DataIntegrityByCount] = None


class Details(PagingInfo):
    results: Optional[List[DataIntegrityDetails]] = None


class Summaries(BaseModel):
    summaries: Optional[List[DataIntegritySummary]] = None


class AccountCategoryDeprecated(AccountCategory):
    modifiedDate: Optional[LastGenerated] = Field(
        None, description='The date on which this record was last modified in Codat.'
    )


class DataIntegrityDates(BaseModel):
    maxDate: Optional[LastGenerated] = Field(
        None, description='Latest date of transaction set.'
    )
    maxOverlappingDate: Optional[LastGenerated] = Field(
        None,
        description='Latest date where transactions exist in both account and banking platforms.',
    )
    minDate: Optional[LastGenerated] = Field(
        None, description='Earliest date of transaction set.'
    )
    minOverlappingDate: Optional[LastGenerated] = Field(
        None,
        description='Earliest date where transactions exist in both accounting and banking platforms.',
    )


class DataIntegrityStatusInfo(BaseModel):
    currentStatus: Optional[IntegrityStatus] = None
    lastMatched: Optional[LastGenerated] = Field(
        None,
        description='The date the matching algorithm last ran against the company’s data type specified.',
    )
    statusMessage: Optional[str] = Field(
        None, description='Detailed explanation supporting the status value.'
    )


class EnhancedReportAccountCategory(BaseModel):
    levels: Optional[List[AccountCategoryLevel]] = None
    status: Optional[str] = Field(
        None,
        description='Returns a status of "Suggested" or "Confirmed". If an account has a confirmed category, it will replace any suggested category returned.',
    )


class EnhancedReportInfo(BaseModel):
    companyName: Optional[str] = Field(None, description='Name of the company queried.')
    currency: Optional[Currency] = Field(
        None, description='Currency of the P&L/Balance sheet.'
    )
    generatedDate: Optional[LastGenerated] = Field(
        None, description='Returns the YYYY-MM-DD datetime of report generation.'
    )
    reportName: Optional[str] = Field(None, description='The name of the report.')


class Error(BaseModel):
    details: Optional[AssessErrorDetails] = None
    message: Optional[str] = Field(
        None,
        description='Description of the error.',
        examples=['There are uncategorized accounts IDs, see details.'],
    )
    type: Optional[Type] = Field(None, description='Metric level error.')


class Error1(BaseModel):
    details: Optional[AssessErrorDetails] = None
    massage: Optional[str] = Field(
        None, description='Description of the error.', examples=['Missing account data']
    )
    type: Optional[Type1] = Field(None, description='Period error type.')


class Period(BaseModel):
    errors: Optional[List[Error1]] = None
    fromDate: Optional[date_aliased] = Field(
        None, description='The date from which the report starts.'
    )
    inputs: Optional[List[Input]] = None
    toDate: Optional[date_aliased] = Field(
        None, description='The date on which the report ends (inclusive of day).'
    )
    value: Optional[float] = Field(
        None,
        description='The top level metric value that is calculated for the specified period. \n\nIf the system cannot calculate for that period, the value will be null. The system will still show the metric inputs.',
    )


class FinancialMetric(BaseModel):
    errors: Optional[List[Error]] = None
    key: Optional[Key] = None
    metricUnit: Optional[MetricUnit] = None
    name: Optional[str] = Field(None, description='Metric name.')
    periods: Optional[List[Period]] = None


class ReportComponent(BaseModel):
    components: Optional[List[ReportComponent]] = None
    dimension: Optional[int] = None
    dimensionDisplayName: Optional[str] = None
    item: Optional[int] = None
    itemDisplayName: Optional[str] = None
    measures: Optional[List[ReportComponentMeasure]] = None


class Accounts(BaseModel):
    accountName: Optional[str] = Field(
        None, description='The name of the account according to the provider.'
    )
    accountProvider: Optional[str] = Field(
        None,
        description='The bank or other financial institution providing the account.',
    )
    accountType: Optional[str] = Field(
        None, description='The type of banking account, e.g. credit or debit.'
    )
    currency: Optional[Currency] = Field(
        None, description='The currency code for the bank account.'
    )
    currentBalance: Optional[float] = Field(
        None, description='The balance of the bank account.'
    )
    platformName: Optional[str] = Field(
        None, description='Name of the banking data source, e.g. "Plaid".'
    )
    sourceRef: Optional[SourceRef] = None


class EnhancedCashFlowTransaction(BaseModel):
    amount: Optional[float] = Field(None, description='The bank transaction amount.')
    currency: Optional[str] = None
    date: Optional[LastGenerated] = Field(
        None, description='The date the bank transaction was posted.'
    )
    description: Optional[str] = Field(
        None, description='The description of the bank transaction.'
    )
    id: Optional[str] = Field(
        None, description='The unique identifier of the bank transaction.'
    )
    sourceRef: Optional[SourceRef] = None
    transactionCategory: Optional[TransactionCategory] = Field(
        None, description='Contains an array of category levels.'
    )


class PaymentLineLink(BaseModel):
    model_config = ConfigDict(
        extra='forbid',
    )
    amount: Optional[float] = Field(
        None,
        description='Amount by which the balance of the linked entity is altered, in the currency of the linked entity.  \nA negative link amount _reduces_ the outstanding amount on the accounts receivable account.  \nA positive link amount _increases_ the outstanding amount on the accounts receivable account.',
    )
    currencyRate: Optional[CurrencyRate] = None
    id: Optional[str] = Field(
        None,
        description='Unique identifier of the transaction represented by the link.',
    )
    type: PaymentLinkType


class CategorisedAccount(BaseModel):
    accountRef: Optional[AccountRef] = None
    confirmed: Optional[AccountCategoryDeprecated] = None
    suggested: Optional[AccountCategoryDeprecated] = None


class CategorisedAccounts(PagingInfo):
    results: Optional[List[CategorisedAccount]] = Field(
        None, description='A list confirmed and suggested account categories.'
    )


class DataIntegrityStatus(DataIntegrityType):
    amounts: Optional[DataIntegrityAmounts] = None
    connectionIds: Optional[DataIntegrityConnectionId] = None
    dates: Optional[DataIntegrityDates] = None
    statusInfo: Optional[DataIntegrityStatusInfo] = None


class ReportItem1(BaseModel):
    accountCategory: Optional[EnhancedReportAccountCategory] = None
    accountId: Optional[str] = Field(None, description='The unique account ID.')
    accountName: Optional[str] = Field(None, description='Name of the account.')
    balance: Optional[float] = Field(
        None,
        description='Balance of the account as reported on the profit and loss or Balance sheet.',
    )
    date: Optional[LastGenerated] = Field(None, description='Last date of the period.')


class EnhancedReport(BaseModel):
    reportInfo: Optional[EnhancedReportInfo] = None
    reportItems: Optional[List[ReportItem1]] = Field(
        None, description='An array of report items.'
    )


class FinancialMetrics(BaseModel):
    currency: Optional[Currency] = None
    errors: Optional[List[FinancialMetricError]] = Field(
        None, description='If there are no errors, an empty array is returned.'
    )
    metrics: Optional[List[FinancialMetric]] = None
    periodUnit: Optional[PeriodUnit] = None


class Report(BaseModel):
    dimensions: Optional[List[ReportDimension]] = None
    errors: Optional[List[ReportError]] = None
    measures: Optional[List[ReportMeasure]] = None
    reportData: Optional[List[ReportComponent]] = None
    reportInfo: Optional[Dict[str, str]] = None


class Status(BaseModel):
    metadata: Optional[List[DataIntegrityStatus]] = None


class DataCompaniesCompanyIdConnectionsConnectionIdAssessAccountsCategoriesPatchResponse(
    RootModel[List[CategorisedAccount]]
):
    root: List[CategorisedAccount]


class DataSource(BaseModel):
    accounts: Optional[List[Accounts]] = Field(
        None,
        description='An array containing bank account data for each connected banking data source that have the following data types enabled: `banking-accounts`, `banking-transactions`.',
    )


class EnhancedCashFlowItem(BaseModel):
    transactions: Optional[List[EnhancedCashFlowTransaction]] = Field(
        None, description='An array of transaction data.'
    )


class PaymentLine(BaseModel):
    allocatedOnDate: Optional[LastGenerated] = Field(
        None, description='The date the payment was allocated.'
    )
    amount: float = Field(..., description='Amount in the payment currency.')
    links: Optional[List[PaymentLineLink]] = None


class EnhancedCashFlowTransactions(BaseModel):
    dataSources: Optional[List[DataSource]] = None
    reportInfo: Optional[ReportInfo] = None
    reportItems: Optional[List[EnhancedCashFlowItem]] = None


class Payment(Field1):
    accountRef: Optional[AccountRef] = Field(
        None,
        description='Account the payment is recorded against in the accounting platform.',
    )
    currency: Optional[Currency] = Field(
        None,
        description='ISO currency code recorded for the payment in the accounting platform.',
    )
    currencyRate: Optional[CurrencyRate] = None
    customerRef: Optional[CustomerRef] = Field(
        None,
        description='Customer the payment is recorded against in the accounting platform.',
    )
    date: LastGenerated = Field(
        ..., description='Date the payment was recorded in the accounting software.'
    )
    id: Optional[str] = Field(
        None,
        description='Identifier for the payment, unique to the company in the accounting platform.',
    )
    lines: Optional[List[PaymentLine]] = Field(
        None, description='An array of payment lines.'
    )
    metadata: Optional[Metadata] = None
    note: Optional[str] = Field(
        None, description='Any additional information associated with the payment.'
    )
    paymentMethodRef: Optional[PaymentMethodRef] = Field(
        None,
        description='The Payment Method to which the payment is linked in the accounting platform.',
    )
    reference: Optional[str] = Field(
        None, description='Friendly reference for the payment.'
    )
    supplementalData: Optional[SupplementalData] = Field(
        None,
        description='Reference to a configured dynamic key value pair that is unique to the accounting platform. This feature is in private beta, contact us if you would like to learn more.',
    )
    totalAmount: Optional[float] = Field(
        None,
        description="Amount of the payment in the payment currency. This value should never change and represents the amount of money paid into the customer's account.",
    )
    sourceModifiedDate: Optional[LastGenerated] = Field(
        None,
        description='The date on which this record was last modified in the originating system',
    )


class EnhancedInvoiceReportItem(BaseModel):
    amountDue: Optional[float] = None
    currency: Optional[Currency] = None
    customerRef: Optional[CustomerRef] = None
    dueDate: Optional[LastGenerated] = None
    id: Optional[str] = Field(
        None,
        description='ID of the invoice, which may be a GUID but it may be something else depending on the accounting platdform',
    )
    invoiceNumber: Optional[str] = None
    issueDate: Optional[LastGenerated] = None
    paidOnDate: Optional[LastGenerated] = None
    payments: Optional[List[Payment]] = None
    status: Optional[InvoiceStatus] = None
    totalAmount: Optional[float] = None


class ReportItem(BaseModel):
    invoices: Optional[List[EnhancedInvoiceReportItem]] = None


class EnhancedInvoicesReport(BaseModel):
    reportInfo: Optional[ReportInfo] = None
    reportItems: Optional[List[ReportItem]] = None


ReportComponent.model_rebuild()
