# generated by fastapi-codegen:
#   filename:  openapi.yaml
#   timestamp: 2025-06-28T18:14:10+00:00



import argparse
import json
import os
from typing import *
from typing import Optional
from uuid import UUID

from autogen.mcp.mcp_proxy import MCPProxy
from autogen.mcp.mcp_proxy.security import APIKeyHeader, BaseSecurity
from fastapi import Path, Query
from pydantic import conint

from models import (
    Categories,
    CategorisedAccount,
    CategorisedAccounts,
    ConfirmCategories,
    ConfirmCategory,
    DataCompaniesCompanyIdAssessExcelDownloadGetResponse,
    DataCompaniesCompanyIdAssessExcelDownloadPostResponse,
    DataCompaniesCompanyIdConnectionsConnectionIdAssessAccountsCategoriesPatchResponse,
    DataType,
    Details,
    EnhancedCashFlowTransactions,
    EnhancedInvoicesReport,
    EnhancedReport,
    ExcelStatus,
    FinancialMetrics,
    PeriodUnit1,
    Report,
    ReportType,
    Status,
    Summaries,
)

app = MCPProxy(
    contact={
        'email': 'support@codat.io',
        'name': 'Codat',
        'url': 'https://www.codat.io/contact/',
    },
    description="Codat's Assess API enable you to make smarter credit decisions on your small business customers. Assess enriches your customer's accounting, commerce and banking data to surface actionable insights you didn't have before.\n\n[Read more...](https://www.codat.io/assess/)\n\n[See our OpenAPI spec](https://github.com/codatio/oas) ",
    summary="Codat's financial insights API",
    termsOfService='https://www.codat.io/legals/',
    title='Assess API',
    version='1.0',
    servers=[{'description': 'Production', 'url': 'https://api.codat.io'}],
)


@app.get(
    '/companies/{companyId}/reports/enhancedBalanceSheet/accounts',
    description=""" The Enhanced Balance Sheet Accounts endpoint returns a list of categorized accounts that appear on a company’s Balance Sheet along with a balance per financial statement date.

Codat suggests a category for each account automatically, but you can [change it](/docs/assess-categorizing-accounts-ecommerce-lending) to a more suitable one. """,
    tags=['financial_report_generation', 'data_integrity_checks'],
    security=[
        APIKeyHeader(name="Authorization"),
    ],
)
def get_accounts_for_enhanced_balance_sheet(
    report_date: str = Query(..., alias='reportDate'),
    number_of_periods: int = Query(..., alias='numberOfPeriods'),
    company_id: UUID = Path(..., alias='companyId'),
):
    """
    Enhanced Balance Sheet Accounts
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/companies/{companyId}/reports/enhancedCashFlow/transactions',
    description=""" The Enhanced Cash Flow Transactions endpoint provides a fully categorized list of banking transactions for a company. Accounts and transaction data are obtained from the company's banking data sources. """,
    tags=['financial_report_generation'],
    security=[
        APIKeyHeader(name="Authorization"),
    ],
)
def get_enhanced_cash_flow_transactions(
    page: conint(ge=0) = 1,
    page_size: Optional[conint(ge=1, le=5000)] = Query(100, alias='pageSize'),
    query: Optional[str] = None,
    company_id: UUID = Path(..., alias='companyId'),
):
    """
    Get enhanced cash flow report
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/companies/{companyId}/reports/enhancedInvoices',
    description=""" Gets a list of invoices linked to the corresponding banking transaction """,
    tags=['financial_report_generation'],
    security=[
        APIKeyHeader(name="Authorization"),
    ],
)
def get_enhanced_invoices_report(
    page: conint(ge=0) = 1,
    page_size: Optional[conint(ge=1, le=5000)] = Query(100, alias='pageSize'),
    query: Optional[str] = None,
    company_id: UUID = Path(..., alias='companyId'),
):
    """
    Enhanced Invoices Report
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/companies/{companyId}/reports/enhancedProfitAndLoss/accounts',
    description=""" The Enhanced Profit and Loss Accounts endpoint returns a list of categorized accounts that appear on a company’s Profit and Loss. It also includes a balance per the financial statement date.

Codat suggests a category for each account automatically, but you can [change it](/docs/assess-categorizing-accounts-ecommerce-lending) to a more suitable one. """,
    tags=['financial_report_generation', 'data_integrity_checks'],
    security=[
        APIKeyHeader(name="Authorization"),
    ],
)
def get_accounts_for_enhanced_profit_and_loss(
    report_date: str = Query(..., alias='reportDate'),
    number_of_periods: int = Query(..., alias='numberOfPeriods'),
    company_id: UUID = Path(..., alias='companyId'),
):
    """
    Enhanced Profit and Loss Accounts
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/data/assess/accounts/categories',
    description=""" Lists available account categories Codat's categorisation engine can provide.  """,
    tags=['account_category_operations'],
    security=[
        APIKeyHeader(name="Authorization"),
    ],
)
def list_available_account_categories():
    """
    List account categories
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/data/companies/{companyId}/assess/dataTypes/{dataType}/dataIntegrity/details',
    description=""" Gets record-by-record match results for a given company and datatype, optionally restricted by a Codat query string. """,
    tags=['data_integrity_checks'],
    security=[
        APIKeyHeader(name="Authorization"),
    ],
)
def get_data_integrity_details(
    page: conint(ge=0) = 1,
    page_size: Optional[conint(ge=1, le=5000)] = Query(100, alias='pageSize'),
    query: Optional[str] = None,
    order_by: Optional[str] = Query(None, alias='orderBy'),
    company_id: UUID = Path(..., alias='companyId'),
    data_type: DataType = Path(..., alias='dataType'),
):
    """
    Lists data integrity details for date type
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/data/companies/{companyId}/assess/dataTypes/{dataType}/dataIntegrity/status',
    description=""" Gets match status for a given company and datatype. """,
    tags=['data_integrity_checks'],
    security=[
        APIKeyHeader(name="Authorization"),
    ],
)
def get_data_integrity_status(
    company_id: UUID = Path(..., alias='companyId'),
    data_type: DataType = Path(..., alias='dataType'),
):
    """
    Get data integrity status
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/data/companies/{companyId}/assess/dataTypes/{dataType}/dataIntegrity/summaries',
    description=""" Gets match summary for a given company and datatype, optionally restricted by a Codat query string. """,
    tags=['data_integrity_checks'],
    security=[
        APIKeyHeader(name="Authorization"),
    ],
)
def get_data_integrity_summaries(
    query: Optional[str] = None,
    company_id: UUID = Path(..., alias='companyId'),
    data_type: DataType = Path(..., alias='dataType'),
):
    """
    Get data integrity summary
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/data/companies/{companyId}/assess/excel',
    description=""" Returns the status of the latest report requested. """,
    tags=['excel_report_management', 'data_integrity_checks'],
    security=[
        APIKeyHeader(name="Authorization"),
    ],
)
def get_excel_report_generation_status(
    report_type: ReportType = Query(..., alias='reportType'),
    company_id: UUID = Path(..., alias='companyId'),
):
    """
    Get status of Excel report
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.post(
    '/data/companies/{companyId}/assess/excel',
    description=""" Generate an Excel report which can subsequently be downloaded. """,
    tags=['excel_report_management', 'financial_report_generation'],
    security=[
        APIKeyHeader(name="Authorization"),
    ],
)
def generate_excel_report(
    report_type: ReportType = Query(..., alias='reportType'),
    company_id: UUID = Path(..., alias='companyId'),
):
    """
    Generate an Excel report
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/data/companies/{companyId}/assess/excel/download',
    description=""" Download the previously generated Excel report to a local drive. """,
    tags=['excel_report_management', 'financial_report_generation'],
    security=[
        APIKeyHeader(name="Authorization"),
    ],
)
def get_excel_report(
    report_type: ReportType = Query(..., alias='reportType'),
    company_id: UUID = Path(..., alias='companyId'),
):
    """
    Download generated excel report
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.post(
    '/data/companies/{companyId}/assess/excel/download',
    description=""" Download the previously generated Excel report to a local drive. """,
    tags=['excel_report_management', 'financial_report_generation'],
    security=[
        APIKeyHeader(name="Authorization"),
    ],
)
def download_excel_report(
    report_type: ReportType = Query(..., alias='reportType'),
    company_id: UUID = Path(..., alias='companyId'),
):
    """
    Download generated excel report
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/data/companies/{companyId}/connections/{connectionId}/assess/accountingMetrics/marketing',
    description=""" Request an Excel report for download. """,
    tags=['financial_report_generation', 'commerce_performance_metrics'],
    security=[
        APIKeyHeader(name="Authorization"),
    ],
)
def get_accounting_marketing_metrics(
    report_date: str = Query(..., alias='reportDate'),
    period_length: int = Query(..., alias='periodLength'),
    number_of_periods: int = Query(..., alias='numberOfPeriods'),
    period_unit: PeriodUnit1 = Query(..., alias='periodUnit'),
    include_display_names: Optional[bool] = Query(None, alias='includeDisplayNames'),
    show_input_values: Optional[bool] = Query(None, alias='showInputValues'),
    company_id: UUID = Path(..., alias='companyId'),
    connection_id: UUID = Path(..., alias='connectionId'),
):
    """
    Get the marketing metrics from an accounting source for a given company.
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/data/companies/{companyId}/connections/{connectionId}/assess/accounts/categories',
    description=""" Lists suggested and confirmed chart of account categories for the given company and data connection. """,
    tags=['account_category_operations'],
    security=[
        APIKeyHeader(name="Authorization"),
    ],
)
def list_accounts_categories(
    page: conint(ge=0) = 1,
    page_size: Optional[conint(ge=1, le=5000)] = Query(100, alias='pageSize'),
    query: Optional[str] = None,
    order_by: Optional[str] = Query(None, alias='orderBy'),
    company_id: UUID = Path(..., alias='companyId'),
    connection_id: UUID = Path(..., alias='connectionId'),
):
    """
    List suggested and confirmed account categories
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.patch(
    '/data/companies/{companyId}/connections/{connectionId}/assess/accounts/categories',
    description=""" Comfirms the categories for all or a batch of accounts for a specific connection. """,
    tags=['account_category_operations', 'data_integrity_checks'],
    security=[
        APIKeyHeader(name="Authorization"),
    ],
)
def update_accounts_categories(
    company_id: UUID = Path(..., alias='companyId'),
    connection_id: UUID = Path(..., alias='connectionId'),
    body: ConfirmCategories = None,
):
    """
    Confirm categories for accounts
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/data/companies/{companyId}/connections/{connectionId}/assess/accounts/{accountId}/categories',
    description=""" Get category for specific nominal account. """,
    tags=['account_category_operations'],
    security=[
        APIKeyHeader(name="Authorization"),
    ],
)
def get_account_category(
    company_id: UUID = Path(..., alias='companyId'),
    connection_id: UUID = Path(..., alias='connectionId'),
    account_id: str = Path(..., alias='accountId'),
):
    """
    Get suggested and/or confirmed category for a specific account
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.patch(
    '/data/companies/{companyId}/connections/{connectionId}/assess/accounts/{accountId}/categories',
    description=""" Update category for a specific nominal account """,
    tags=['account_category_operations'],
    security=[
        APIKeyHeader(name="Authorization"),
    ],
)
def update_account_category(
    company_id: UUID = Path(..., alias='companyId'),
    connection_id: UUID = Path(..., alias='connectionId'),
    account_id: str = Path(..., alias='accountId'),
    body: ConfirmCategory = None,
):
    """
    Patch account categories
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/data/companies/{companyId}/connections/{connectionId}/assess/commerceMetrics/customerRetention',
    description=""" Gets the customer retention metrics for a specific company connection, over one or more periods of time. """,
    tags=['commerce_performance_metrics', 'subscription_revenue_metrics'],
    security=[
        APIKeyHeader(name="Authorization"),
    ],
)
def get_commerce_customer_retention_metrics(
    report_date: str = Query(..., alias='reportDate'),
    period_length: int = Query(..., alias='periodLength'),
    number_of_periods: int = Query(..., alias='numberOfPeriods'),
    period_unit: PeriodUnit1 = Query(..., alias='periodUnit'),
    include_display_names: Optional[bool] = Query(None, alias='includeDisplayNames'),
    company_id: UUID = Path(..., alias='companyId'),
    connection_id: UUID = Path(..., alias='connectionId'),
):
    """
    Get the customer retention metrics for a specific company.
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/data/companies/{companyId}/connections/{connectionId}/assess/commerceMetrics/lifetimeValue',
    description=""" Gets the lifetime value metric for a specific company connection, over one or more periods of time. """,
    tags=['commerce_performance_metrics', 'subscription_revenue_metrics'],
    security=[
        APIKeyHeader(name="Authorization"),
    ],
)
def get_commerce_lifetime_value_metrics(
    report_date: str = Query(..., alias='reportDate'),
    period_length: int = Query(..., alias='periodLength'),
    number_of_periods: int = Query(..., alias='numberOfPeriods'),
    period_unit: PeriodUnit1 = Query(..., alias='periodUnit'),
    include_display_names: Optional[bool] = Query(None, alias='includeDisplayNames'),
    company_id: UUID = Path(..., alias='companyId'),
    connection_id: UUID = Path(..., alias='connectionId'),
):
    """
    Get the lifetime value metric for a specific company.
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/data/companies/{companyId}/connections/{connectionId}/assess/commerceMetrics/orders',
    description=""" Gets the order information for a specific company connection, over one or more periods of time. """,
    tags=['financial_report_generation', 'commerce_performance_metrics'],
    security=[
        APIKeyHeader(name="Authorization"),
    ],
)
def get_commerce_orders_metrics(
    report_date: str = Query(..., alias='reportDate'),
    period_length: int = Query(..., alias='periodLength'),
    number_of_periods: int = Query(..., alias='numberOfPeriods'),
    period_unit: PeriodUnit1 = Query(..., alias='periodUnit'),
    include_display_names: Optional[bool] = Query(None, alias='includeDisplayNames'),
    company_id: UUID = Path(..., alias='companyId'),
    connection_id: UUID = Path(..., alias='connectionId'),
):
    """
    Get order information for a specific company
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/data/companies/{companyId}/connections/{connectionId}/assess/commerceMetrics/refunds',
    description=""" Gets the refunds information for a specific company connection, over one or more periods of time. """,
    tags=['financial_report_generation', 'commerce_performance_metrics'],
    security=[
        APIKeyHeader(name="Authorization"),
    ],
)
def get_commerce_refunds_metrics(
    report_date: str = Query(..., alias='reportDate'),
    period_length: int = Query(..., alias='periodLength'),
    number_of_periods: int = Query(..., alias='numberOfPeriods'),
    period_unit: PeriodUnit1 = Query(..., alias='periodUnit'),
    include_display_names: Optional[bool] = Query(None, alias='includeDisplayNames'),
    company_id: UUID = Path(..., alias='companyId'),
    connection_id: UUID = Path(..., alias='connectionId'),
):
    """
    Get the refunds information for a specific company
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/data/companies/{companyId}/connections/{connectionId}/assess/commerceMetrics/revenue',
    description=""" Get the revenue and revenue growth for a specific company connection, over one or more periods of time. """,
    tags=['commerce_performance_metrics', 'subscription_revenue_metrics'],
    security=[
        APIKeyHeader(name="Authorization"),
    ],
)
def get_commerce_revenue_metrics(
    report_date: str = Query(..., alias='reportDate'),
    period_length: int = Query(..., alias='periodLength'),
    number_of_periods: int = Query(..., alias='numberOfPeriods'),
    period_unit: PeriodUnit1 = Query(..., alias='periodUnit'),
    include_display_names: Optional[bool] = Query(None, alias='includeDisplayNames'),
    company_id: UUID = Path(..., alias='companyId'),
    connection_id: UUID = Path(..., alias='connectionId'),
):
    """
    Commerce Revenue Metrics
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/data/companies/{companyId}/connections/{connectionId}/assess/enhancedBalanceSheet',
    description=""" Gets a fully categorized balance sheet statement for a given company, over one or more period(s). """,
    tags=['financial_report_generation'],
    security=[
        APIKeyHeader(name="Authorization"),
    ],
)
def get_enhanced_balance_sheet(
    report_date: str = Query(..., alias='reportDate'),
    period_length: int = Query(..., alias='periodLength'),
    number_of_periods: int = Query(..., alias='numberOfPeriods'),
    include_display_names: Optional[bool] = Query(None, alias='includeDisplayNames'),
    company_id: UUID = Path(..., alias='companyId'),
    connection_id: UUID = Path(..., alias='connectionId'),
):
    """
    Enhanced Balance Sheet
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/data/companies/{companyId}/connections/{connectionId}/assess/enhancedProfitAndLoss',
    description=""" Gets a fully categorized profit and loss statement for a given company, over one or more period(s). """,
    tags=['financial_report_generation'],
    security=[
        APIKeyHeader(name="Authorization"),
    ],
)
def get_enhanced_profit_and_loss(
    report_date: str = Query(..., alias='reportDate'),
    period_length: int = Query(..., alias='periodLength'),
    number_of_periods: int = Query(..., alias='numberOfPeriods'),
    include_display_names: Optional[bool] = Query(None, alias='includeDisplayNames'),
    company_id: UUID = Path(..., alias='companyId'),
    connection_id: UUID = Path(..., alias='connectionId'),
):
    """
    Enhanced Profit and Loss
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/data/companies/{companyId}/connections/{connectionId}/assess/financialMetrics',
    description=""" Gets all the available financial metrics for a given company, over one or more periods. """,
    tags=['financial_report_generation', 'commerce_performance_metrics'],
    security=[
        APIKeyHeader(name="Authorization"),
    ],
)
def get_enhanced_financial_metrics(
    report_date: str = Query(..., alias='reportDate'),
    period_length: int = Query(..., alias='periodLength'),
    number_of_periods: int = Query(..., alias='numberOfPeriods'),
    show_metric_inputs: Optional[bool] = Query(None, alias='showMetricInputs'),
    company_id: UUID = Path(..., alias='companyId'),
    connection_id: UUID = Path(..., alias='connectionId'),
):
    """
    List financial metrics
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/data/companies/{companyId}/connections/{connectionId}/assess/subscriptions/mrr',
    description=""" Gets key metrics for subscription revenue. """,
    tags=['subscription_revenue_metrics', 'commerce_performance_metrics'],
    security=[
        APIKeyHeader(name="Authorization"),
    ],
)
def get_recurring_revenue_metrics(
    company_id: UUID = Path(..., alias='companyId'),
    connection_id: UUID = Path(..., alias='connectionId'),
):
    """
    Get key metrics for subscription revenue
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/data/companies/{companyId}/connections/{connectionId}/assess/subscriptions/process',
    description=""" Request production of key subscription revenue metrics. """,
    tags=['subscription_revenue_metrics', 'commerce_performance_metrics'],
    security=[
        APIKeyHeader(name="Authorization"),
    ],
)
def request_recurring_revenue_metrics(
    company_id: UUID = Path(..., alias='companyId'),
    connection_id: UUID = Path(..., alias='connectionId'),
):
    """
    Request production of key subscription revenue metrics
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


if __name__ == "__main__":
    parser = argparse.ArgumentParser(description="MCP Server")
    parser.add_argument(
        "transport",
        choices=["stdio", "sse", "streamable-http"],
        help="Transport mode (stdio, sse or streamable-http)",
    )
    args = parser.parse_args()

    if "CONFIG_PATH" in os.environ:
        config_path = os.environ["CONFIG_PATH"]
        app.load_configuration(config_path)

    if "CONFIG" in os.environ:
        config = os.environ["CONFIG"]
        app.load_configuration_from_string(config)

    if "SECURITY" in os.environ:
        security_params = BaseSecurity.parse_security_parameters_from_env(
            os.environ,
        )

        app.set_security_params(security_params)

    mcp_settings = json.loads(os.environ.get("MCP_SETTINGS", "{}"))

    app.get_mcp(**mcp_settings).run(transport=args.transport)
